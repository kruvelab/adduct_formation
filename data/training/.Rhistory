atoms == "O" & bond_count < 2 ~ 1,
atoms == "C" & bond_count < 4 ~ 1,
TRUE ~ 0
))
return(which(names_of_atoms$is_available_for_connection == 1))
}
#base structure----
SMILES <- "c1cc(O)ccc1(O)"
m <- parse.smiles(SMILES)[[1]]
matrix_with_bond_count <- get.connection.matrix(m)
#matrix <- get.adjacency.matrix(m)
atoms <- get.atoms(m)
names_of_atoms <- tibble(atoms = character())
for (i in 1:length(atoms)) {
names_of_atoms <- names_of_atoms %>%
add_row(atoms = get.symbol(atoms[[i]]))
}
graph = igraph::graph_from_adjacency_matrix(matrix_with_bond_count)
graph1 = set.vertex.attribute(graph, "name", value=as.character(1:length(atoms)))
#added substructure ----
SMILES2 <- "C(=O)O"
m2 <- parse.smiles(SMILES2)[[1]]
matrix_with_bond_count2 <- get.connection.matrix(m2)
atoms2 <- get.atoms(m2)
names_of_atoms2 <- tibble(atoms2 = character())
for (i in 1:length(atoms2)) {
names_of_atoms2 <- names_of_atoms2 %>%
add_row(atoms2 = get.symbol(atoms2[[i]]))
}
#matrix2 <- get.adjacency.matrix(m2)
graph2 = igraph::graph_from_adjacency_matrix(matrix_with_bond_count2)
graph2 = set.vertex.attribute(graph2, "name", value=as.character((length(atoms)+1):(length(atoms)+length(atoms2))))
graph <- graph %>%
add_vertices(3)
union_graph = igraph::union(graph1, graph2)
plot(union_graph)
union_graph_matrix = as.matrix(as_adjacency_matrix(union_graph))
union_graph = graph_from_adjacency_matrix(union_graph_matrix)
x = atoms_available_for_connection(m, matrix_with_bond_count)
y = atoms_available_for_connection(m2, matrix_with_bond_count2)
connections = c(sample(x, size = 1),
sample(y, size = 1)+length(atoms))
union_graph = union_graph %>%
add.edges(connections)
plot(union_graph)
atoms_available_for_connection = function(m, matrix_with_bond_count) {
atoms <- get.atoms(m)
names_of_atoms <- tibble(atoms = character())
for (i in 1:length(atoms)) {
names_of_atoms <- names_of_atoms %>%
add_row(atoms = get.symbol(atoms[[i]]))
}
names_of_atoms = names_of_atoms %>%
add_column(bond_count = colSums(matrix_with_bond_count))
names_of_atoms = names_of_atoms %>%
mutate(is_available_for_connection = case_when(
atoms == "O" & bond_count < 2 ~ 1,
atoms == "C" & bond_count < 4 ~ 1,
TRUE ~ 0
))
return(which(names_of_atoms$is_available_for_connection == 1))
}
#base structure----
SMILES <- "c1cc(O)ccc1(O)"
m <- parse.smiles(SMILES)[[1]]
matrix_with_bond_count <- get.connection.matrix(m)
#matrix <- get.adjacency.matrix(m)
atoms <- get.atoms(m)
names_of_atoms <- tibble(atoms = character())
for (i in 1:length(atoms)) {
names_of_atoms <- names_of_atoms %>%
add_row(atoms = get.symbol(atoms[[i]]))
}
graph = igraph::graph_from_adjacency_matrix(matrix_with_bond_count)
graph1 = set.vertex.attribute(graph, "name", value=as.character(1:length(atoms)))
#added substructure ----
SMILES2 <- "C(=O)O"
m2 <- parse.smiles(SMILES2)[[1]]
matrix_with_bond_count2 <- get.connection.matrix(m2)
atoms2 <- get.atoms(m2)
names_of_atoms2 <- tibble(atoms2 = character())
for (i in 1:length(atoms2)) {
names_of_atoms2 <- names_of_atoms2 %>%
add_row(atoms2 = get.symbol(atoms2[[i]]))
}
#matrix2 <- get.adjacency.matrix(m2)
graph2 = igraph::graph_from_adjacency_matrix(matrix_with_bond_count2)
graph2 = set.vertex.attribute(graph2, "name", value=as.character((length(atoms)+1):(length(atoms)+length(atoms2))))
graph <- graph %>%
add_vertices(3)
union_graph = igraph::union(graph1, graph2)
plot(union_graph)
union_graph_matrix = as.matrix(as_adjacency_matrix(union_graph))
union_graph = graph_from_adjacency_matrix(union_graph_matrix)
x = atoms_available_for_connection(m, matrix_with_bond_count)
y = atoms_available_for_connection(m2, matrix_with_bond_count2)
connections = c(sample(x, size = 1),
sample(y, size = 1)+length(atoms))
union_graph = union_graph %>%
add.edges(connections)
plot(union_graph)
atoms_available_for_connection = function(m, matrix_with_bond_count) {
atoms <- get.atoms(m)
names_of_atoms <- tibble(atoms = character())
for (i in 1:length(atoms)) {
names_of_atoms <- names_of_atoms %>%
add_row(atoms = get.symbol(atoms[[i]]))
}
names_of_atoms = names_of_atoms %>%
add_column(bond_count = colSums(matrix_with_bond_count))
names_of_atoms = names_of_atoms %>%
mutate(is_available_for_connection = case_when(
atoms == "O" & bond_count < 2 ~ 1,
atoms == "C" & bond_count < 4 ~ 1,
TRUE ~ 0
))
return(which(names_of_atoms$is_available_for_connection == 1))
}
#base structure----
SMILES <- "c1cc(O)ccc1(O)"
m <- parse.smiles(SMILES)[[1]]
matrix_with_bond_count <- get.connection.matrix(m)
#matrix <- get.adjacency.matrix(m)
atoms <- get.atoms(m)
names_of_atoms <- tibble(atoms = character())
for (i in 1:length(atoms)) {
names_of_atoms <- names_of_atoms %>%
add_row(atoms = get.symbol(atoms[[i]]))
}
graph = igraph::graph_from_adjacency_matrix(matrix_with_bond_count)
graph1 = set.vertex.attribute(graph, "name", value=as.character(1:length(atoms)))
#added substructure ----
SMILES2 <- "C(=O)O"
m2 <- parse.smiles(SMILES2)[[1]]
matrix_with_bond_count2 <- get.connection.matrix(m2)
atoms2 <- get.atoms(m2)
names_of_atoms2 <- tibble(atoms2 = character())
for (i in 1:length(atoms2)) {
names_of_atoms2 <- names_of_atoms2 %>%
add_row(atoms2 = get.symbol(atoms2[[i]]))
}
#matrix2 <- get.adjacency.matrix(m2)
graph2 = igraph::graph_from_adjacency_matrix(matrix_with_bond_count2)
graph2 = set.vertex.attribute(graph2, "name", value=as.character((length(atoms)+1):(length(atoms)+length(atoms2))))
graph <- graph %>%
add_vertices(3)
union_graph = igraph::union(graph1, graph2)
plot(union_graph)
union_graph_matrix = as.matrix(as_adjacency_matrix(union_graph))
union_graph = graph_from_adjacency_matrix(union_graph_matrix)
x = atoms_available_for_connection(m, matrix_with_bond_count)
y = atoms_available_for_connection(m2, matrix_with_bond_count2)
connections = c(sample(x, size = 1),
sample(y, size = 1)+length(atoms))
union_graph = union_graph %>%
add.edges(connections)
plot(union_graph)
atoms_available_for_connection = function(m, matrix_with_bond_count) {
atoms <- get.atoms(m)
names_of_atoms <- tibble(atoms = character())
for (i in 1:length(atoms)) {
names_of_atoms <- names_of_atoms %>%
add_row(atoms = get.symbol(atoms[[i]]))
}
names_of_atoms = names_of_atoms %>%
add_column(bond_count = colSums(matrix_with_bond_count))
names_of_atoms = names_of_atoms %>%
mutate(is_available_for_connection = case_when(
atoms == "O" & bond_count < 2 ~ 1,
atoms == "C" & bond_count < 4 ~ 1,
TRUE ~ 0
))
return(which(names_of_atoms$is_available_for_connection == 1))
}
#base structure----
SMILES <- "c1cc(O)ccc1(O)"
m <- parse.smiles(SMILES)[[1]]
matrix_with_bond_count <- get.connection.matrix(m)
#matrix <- get.adjacency.matrix(m)
atoms <- get.atoms(m)
names_of_atoms <- tibble(atoms = character())
for (i in 1:length(atoms)) {
names_of_atoms <- names_of_atoms %>%
add_row(atoms = get.symbol(atoms[[i]]))
}
graph = igraph::graph_from_adjacency_matrix(matrix_with_bond_count)
graph1 = set.vertex.attribute(graph, "name", value=as.character(1:length(atoms)))
#added substructure ----
SMILES2 <- "C(=O)O"
m2 <- parse.smiles(SMILES2)[[1]]
matrix_with_bond_count2 <- get.connection.matrix(m2)
atoms2 <- get.atoms(m2)
names_of_atoms2 <- tibble(atoms2 = character())
for (i in 1:length(atoms2)) {
names_of_atoms2 <- names_of_atoms2 %>%
add_row(atoms2 = get.symbol(atoms2[[i]]))
}
#matrix2 <- get.adjacency.matrix(m2)
graph2 = igraph::graph_from_adjacency_matrix(matrix_with_bond_count2)
graph2 = set.vertex.attribute(graph2, "name", value=as.character((length(atoms)+1):(length(atoms)+length(atoms2))))
graph <- graph %>%
add_vertices(3)
union_graph = igraph::union(graph1, graph2)
plot(union_graph)
union_graph_matrix = as.matrix(as_adjacency_matrix(union_graph))
union_graph = graph_from_adjacency_matrix(union_graph_matrix)
x = atoms_available_for_connection(m, matrix_with_bond_count)
y = atoms_available_for_connection(m2, matrix_with_bond_count2)
connections = c(sample(x, size = 1),
sample(y, size = 1)+length(atoms))
union_graph = union_graph %>%
add.edges(connections)
plot(union_graph)
View(names_of_atoms)
library(fingerprint)
library(rcdk)
library(fingerprint)
sp <- get.smiles.parser()
smiles <- c('CCC', 'CCN', 'CCN(C)(C)', 'c1ccccc1Cc1ccccc1','C1CCC1CC(CN(C)(C))CC(=O)CC')
mols <- parse.smiles(smiles)
fp <- get.fingerprint(mols[[1]])
fps <- lapply(mols, get.fingerprint, type='maccs')
fp.to.matrix(fp)
fp.to.matrix(fps)
as.data.frame(fp.to.matrix(fps))
## get Substructure count fingerprint for user defined fragments
mol1 <- parse.smiles("c1ccccc1CCC")[[1]]
smarts <- c("c1ccccc1", "[CX4H3][#6]", "[CX2]#[CX2]")
fps <- get.fingerprint(mol1, type='substructure', fp.mode='count',
substructure.pattern=smarts)
as.data.frame(fp.to.matrix(fps))
fps
library(tidyverse)
library(caret)
library(gmodels)
library(caTools)
setwd("C:/Users/annel/OneDrive - Kruvelab/Kruvelab/computational/IE mudeli script ja failid/adduct_formation/code")
source('my_theme.R')
setwd("C:/Users/annel/OneDrive - Kruvelab/Kruvelab/computational/IE mudeli script ja failid/adduct_formation/data/training")
#Adduct data ----
#UT data-----
UT_data = read_delim("UT_adducts_CID.csv",
delim = ",",
col_names = TRUE) %>%
na.omit()
UT_data = UT_data %>%
mutate(M_H = case_when(
Class == 0 ~ 1,
Class == 2 ~ 1,
TRUE ~ 0
),
M_Na = case_when(
Class == 1 ~ 1,
Class == 2 ~ 1,
TRUE ~ 0
),
Lab = "UT")
UT_data  %>%
group_by(M_Na) %>%
summarise(n())
set.seed(123)
#there are about 2x so (224 vs 127) many compounds not forming an adduct as there are ones forming an adduct
UT_data_adduct = sample_n(UT_data %>%
filter(M_Na == 1),
size = 100,
replace = FALSE)
UT_data_No_adduct = sample_n(UT_data %>%
filter(M_Na == 0),
size = 100,
replace = FALSE)
UT_data_balanced = UT_data_adduct %>%
bind_rows(UT_data_No_adduct)
Corey_data = read_delim("Corey_adducts_CID.csv",
delim = ",",
col_names = TRUE)
Corey_data = Corey_data %>%
mutate(M_Na = case_when(
Class == 1 ~ 1,
Class == 2 ~ 1,
TRUE ~ 0),
Lab = "Corey")
Corey_data  %>%
group_by(M_Na) %>%
summarise(n())
#there are about 6x so (72 vs 525) many compounds forming an adduct as there are ones forming an adduct
Corey_data_No_adduct = sample_n(Corey_data %>%
filter(M_Na == 0),
size = 100,
replace = TRUE)
Corey_data_adduct = sample_n(Corey_data %>%
filter(M_Na == 1),
size = 100,
replace = FALSE)
Corey_data_balanced = Corey_data_adduct %>%
bind_rows(Corey_data_No_adduct)
SU_data = read_delim("SU_adducts_CID.csv",
delim = ",",
col_names = TRUE)
SU_data = SU_data %>%
mutate(M_Na = case_when(
SlopeNa == 0 ~ 0,
TRUE ~ 1),
M_H = case_when(
SlopeH == 0 ~ 0,
TRUE ~ 1),
Lab = "SU")
SU_data  %>%
group_by(M_Na, M_H) %>%
summarise(n())
SU_data_adduct = sample_n(SU_data %>%
filter(M_Na == 1),
size = 50,
replace = TRUE)
SU_data_No_adduct = sample_n(SU_data %>%
filter(M_Na == 0),
size = 50,
replace = TRUE)
SU_data_balanced = SU_data_adduct %>%
bind_rows(SU_data_No_adduct)
Celma_data = read_delim("Celma_adduct_CID.csv",
delim = ",",
col_names = TRUE)
Celma_data  %>%
group_by(M_Na) %>%
summarise(n())
Celma_data_adduct = sample_n(Celma_data %>%
filter(M_Na == 1),
size = 200,
replace = FALSE)
Celma_data_No_adduct = sample_n(Celma_data %>%
filter(M_Na == 0),
size = 200,
replace = FALSE)
Celma_data_balanced = Celma_data_adduct %>%
bind_rows(Celma_data_No_adduct)
Picache_data = read_delim("Picache_adducts_CID.csv",
delim = ",",
col_names = TRUE)
Picache_data = Picache_data %>%
filter(Adduct == "[M+Na]" | Adduct == "[M+H]") %>%
select(PubChemCID, Adduct, CCS) %>%
na.omit() %>%
group_by(PubChemCID, Adduct) %>%
summarise(CCS = mean(CCS)) %>%
ungroup()
Picache_data = Picache_data %>%
spread(key = Adduct, value = CCS)
View(Picache_data)
Picache_data %>% na.omit()
Picache_data = Picache_data %>%
mutate(M_Na = case_when(
is.na(`[M+Na]`) ~ 0,
TRUE ~ 1
))
Picache_data = Picache_data %>%
select(PubChemCID, M_Na) %>%
mutate(Lab = "Picache")
Picache_data  %>%
group_by(M_Na) %>%
summarise(n())
Picache_data_adduct = sample_n(Picache_data %>%
filter(M_Na == 1),
size = 100,
replace = FALSE)
Picache_data_No_adduct = sample_n(Picache_data %>%
filter(M_Na == 0),
size = 100,
replace = FALSE)
Picache_data_balanced = Picache_data_adduct %>%
bind_rows(Picache_data_No_adduct)
data_all = UT_data %>%
bind_rows(Corey_data) %>%
bind_rows(SU_data) %>%
bind_rows(Celma_data) %>%
bind_rows(Picache_data)
data = UT_data_balanced %>%
bind_rows(Corey_data_balanced) %>%
bind_rows(SU_data_balanced) %>%
bind_rows(Celma_data_balanced) %>%
bind_rows(Picache_data_balanced) %>%
select(-Name, -Class, -M_H, -SlopeH, -SlopeNa)
data_test = data_all %>%
anti_join(data)
fingerprints <- read_delim("PubChem_fingerprints_Bond_properties.csv",
delim = ",",
col_names = TRUE) %>%
select(-SMILES, -X1, -SDFlineStart, -SDFlineEnd, -SDFID, -Fingerprint) %>%
select(everything(), PubChemCID)
fingerprints <- fingerprints %>%
select(-caret::nearZeroVar(fingerprints)) #removing fingerprints that do not change significantely between samples
fingerprints_with_NA <- fingerprints %>%
select(everything()) %>%
summarise_all(funs(sum(is.na(.))))
fingerprints <- fingerprints %>%
na.omit() %>%
unique()
#Putting adduct data and fingerprints together----
data <- data %>%
na.omit() %>%
left_join(fingerprints)%>%
na.omit()
compounds = data %>%
select(PubChemCID) %>%
unique()
set.seed(987123)
#it turns out that for some labs there are still features with zero variance in and these need to be removed
data_train = data_train %>%
select(-PubChemCID, -Lab, -M_Na, everything())
for (lab in levels(as.factor(data_train$Lab))) {
data_train <- data_train %>%
select(-caret::nearZeroVar(data_train %>%
filter(Lab == lab) %>%
select(-PubChemCID, -Lab, -M_Na)))
}
#it turns out that for some labs there are still features with zero variance in and these need to be removed
data_train = data %>%
select(-PubChemCID, -Lab, -M_Na, everything())
for (lab in levels(as.factor(data_train$Lab))) {
data_train <- data_train %>%
select(-caret::nearZeroVar(data_train %>%
filter(Lab == lab) %>%
select(-PubChemCID, -Lab, -M_Na)))
}
folds <- groupKFold(data_train$Lab, k = 5)
fitControl <- trainControl(method = "repeatedcv",
number = 5,
repeats = 1,
index = folds,
classProbs = TRUE)
set.seed(987123)
classifier_svmpoly <- train(M_Na ~ .,
data = data_train %>%
select(-PubChemCID, -Lab),
method = "svmPoly",
trControl = fitControl,
metric = "ROC")
saveRDS(classifier_svmpoly,
file = "classifier_svmpoly.rds")
data = read_delim("balanced_adduct_data_training.csv",
delim = ",",
col_names = TRUE)
compounds = data %>%
select(PubChemCID) %>%
unique()
set.seed(987123)
data_train = data %>%
mutate(M_Na = case_when(
M_Na == 1 ~ "yes",
TRUE ~ "no"
)) %>%
mutate(M_Na = factor(M_Na,
levels = c("no", "yes")))
#it turns out that for some labs there are still features with zero variance in and these need to be removed
data_train = data_train %>%
select(-PubChemCID, -Lab, -M_Na, everything())
for (lab in levels(as.factor(data_train$Lab))) {
data_train <- data_train %>%
select(-caret::nearZeroVar(data_train %>%
filter(Lab == lab) %>%
select(-PubChemCID, -Lab, -M_Na)))
}
folds <- groupKFold(data_train$Lab, k = 5)
fitControl <- trainControl(method = "repeatedcv",
number = 5,
repeats = 1,
index = folds,
classProbs = TRUE)
set.seed(987123)
classifier_svmpoly <- train(M_Na ~ .,
data = data_train %>%
select(-PubChemCID, -Lab),
method = "svmPoly",
trControl = fitControl,
metric = "ROC")
classifier_svmpoly
MLmetrics::F1_Score(data_train$M_Na, predict(classifier_svmpoly, newdata = data_train))
mltools::mcc(predict(classifier_svmpoly, newdata = data_train), data_train$M_Na)
roc_Imp = filterVarImp(x = data_train[, -ncol(data_train)], y = data_train$M_Na)
View(roc_Imp)
set.seed(987123)
classifier_svmlinear <- train(M_Na ~ .,
data = data_train %>%
select(-PubChemCID, -Lab),
method = "svmLinear",
trControl = fitControl)
classifier_svmlinear
MLmetrics::F1_Score(data_train$M_Na, predict(classifier_svmlinear, newdata = data_train))
mltools::mcc(predict(classifier_svmlinear, newdata = data_train), data_train$M_Na)
#data format for RRF and others-----
data_train = data %>%
mutate(M_Na = factor(M_Na))
#it turns out that for some labs there are still features with zero variance in and these need to be removed
data_train = data_train %>%
select(-PubChemCID, -Lab, -M_Na, everything())
for (lab in levels(as.factor(data_train$Lab))) {
data_train <- data_train %>%
select(-caret::nearZeroVar(data_train %>%
filter(Lab == lab) %>%
select(-PubChemCID, -Lab, -M_Na)))
}
folds <- groupKFold(data_train$Lab, k = 5)
fitControl <- trainControl(method = "repeatedcv",
number = 5,
repeats = 1,
index = folds)
set.seed(987123)
classifier_RRF <- train(M_Na ~ .,
data = data_train %>%
select(-PubChemCID, -Lab),
method = "RRF",
trControl = fitControl)
classifier_RRF
